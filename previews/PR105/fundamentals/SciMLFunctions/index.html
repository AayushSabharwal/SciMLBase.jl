<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SciMLFunctions (Jacobians, Sparsity, Etc.) · SciMLBase.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://scimlbase.sciml.ai/stable/fundamentals/SciMLFunctions/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="SciMLBase.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SciMLBase.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Fundamentals</span><ul><li><a class="tocitem" href="../Problems/">Problem Types</a></li><li><a class="tocitem" href="../PDE/">The PDE Definition Interface</a></li><li class="is-active"><a class="tocitem" href>SciMLFunctions (Jacobians, Sparsity, Etc.)</a><ul class="internal"><li><a class="tocitem" href="#Function-Type-Definitions"><span>Function Type Definitions</span></a></li><li><a class="tocitem" href="#In-place-Specification-and-No-Recompile-Mode"><span>In-place Specification and No-Recompile Mode</span></a></li><li><a class="tocitem" href="#Specifying-Jacobian-Types"><span>Specifying Jacobian Types</span></a></li><li><a class="tocitem" href="#Sparsity-Handling"><span>Sparsity Handling</span></a></li><li><a class="tocitem" href="#SciMLFunctions-API"><span>SciMLFunctions API</span></a></li></ul></li><li><a class="tocitem" href="../Differentiation/">Controls for Automatic Differentiation</a></li><li><a class="tocitem" href="../FAQ/">Frequently Asked Questions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Fundamentals</a></li><li class="is-active"><a href>SciMLFunctions (Jacobians, Sparsity, Etc.)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>SciMLFunctions (Jacobians, Sparsity, Etc.)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/SciMLBase.jl/blob/master/docs/src/fundamentals/SciMLFunctions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SciMLFunctions-(Jacobians,-Sparsity,-Etc.)"><a class="docs-heading-anchor" href="#SciMLFunctions-(Jacobians,-Sparsity,-Etc.)">SciMLFunctions (Jacobians, Sparsity, Etc.)</a><a id="SciMLFunctions-(Jacobians,-Sparsity,-Etc.)-1"></a><a class="docs-heading-anchor-permalink" href="#SciMLFunctions-(Jacobians,-Sparsity,-Etc.)" title="Permalink"></a></h1><p>The SciML ecosystem provides an extensive interface for declaring extra functions associated with the differential equation&#39;s data. In traditional libraries there is usually only one option: the Jacobian. However, we allow for a large array of pre-computed functions to speed up the calculations. This is offered via the <code>SciMLFunction</code> types which can be passed to the problems.</p><h2 id="Function-Type-Definitions"><a class="docs-heading-anchor" href="#Function-Type-Definitions">Function Type Definitions</a><a id="Function-Type-Definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Type-Definitions" title="Permalink"></a></h2><h3 id="Common-Function-Choice-Definitions"><a class="docs-heading-anchor" href="#Common-Function-Choice-Definitions">Common Function Choice Definitions</a><a id="Common-Function-Choice-Definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Function-Choice-Definitions" title="Permalink"></a></h3><p>The full interface available to the solvers is as follows:</p><ul><li><code>jac</code>: The Jacobian of the differential equation with respect to the state variable <code>u</code> at a time <code>t</code> with parameters <code>p</code>.</li><li><code>paramjac</code>: The Jacobian of the differential equation with respect to <code>p</code> at state <code>u</code> at time <code>t</code>.</li><li><code>analytic</code>: Defines an analytical solution using <code>u0</code> at time <code>t</code> with <code>p</code> which will cause the solvers to return errors. Used for testing.</li><li><code>syms</code>: Allows you to name your variables for automatic names in plots and other output.</li><li><code>jac_prototype</code>: Defines the type to be used for any internal Jacobians within the solvers.</li><li><code>sparsity</code>: Defines the sparsity pattern to be used for the sparse differentiation schemes. By default this is equal to <code>jac_prototype</code>. See the sparsity handling portion of this page for more information.</li><li><code>colorvec</code>: The coloring pattern used by the sparse differentiator. See the sparsity handling portion of this page for more information.</li><li><code>observed</code>: A function which allows for generating other observables from a solution.</li></ul><p>Each function type additionally has some specific arguments, refer to their documentation for details.</p><h2 id="In-place-Specification-and-No-Recompile-Mode"><a class="docs-heading-anchor" href="#In-place-Specification-and-No-Recompile-Mode">In-place Specification and No-Recompile Mode</a><a id="In-place-Specification-and-No-Recompile-Mode-1"></a><a class="docs-heading-anchor-permalink" href="#In-place-Specification-and-No-Recompile-Mode" title="Permalink"></a></h2><p>Each SciMLFunction type can be called with an &quot;is inplace&quot; (iip) choice.</p><pre><code class="language-julia hljs">ODEFunction(f)
ODEFunction{iip}(f)</code></pre><p>which is a boolean for whether the function is in the inplace form (mutating to change the first value). This is automatically determined using the methods table but note that for full type-inferrability of the <code>SciMLProblem</code> this iip-ness should be specified.</p><p>Additionally, the functions are fully specialized to reduce the runtimes. If one would instead like to not specialize on the functions to reduce compile time, then one can set <code>recompile</code> to false.</p><pre><code class="language-julia hljs">ODEFunction{iip,false}(f)</code></pre><p>This makes the ODE solver compilation independent of the function and so changing the function will not cause recompilation. One can change the default value by changing the <code>const RECOMPILE_BY_DEFAULT = true</code> to false in the SciMLBase.jl source code.</p><h2 id="Specifying-Jacobian-Types"><a class="docs-heading-anchor" href="#Specifying-Jacobian-Types">Specifying Jacobian Types</a><a id="Specifying-Jacobian-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Specifying-Jacobian-Types" title="Permalink"></a></h2><p>The <code>jac</code> field of an inplace style <code>SciMLFunction</code> has the signature <code>jac(J,u,p,t)</code>, which updates the jacobian <code>J</code> in-place. The intended type for <code>J</code> can sometimes be inferred (e.g. when it is just a dense <code>Matrix</code>), but not in general. To supply the type information, you can provide a <code>jac_prototype</code> in the function&#39;s constructor.</p><p>The following example creates an inplace <code>ODEFunction</code> whose jacobian is a <code>Diagonal</code>:</p><pre><code class="language-julia hljs">using LinearAlgebra
f = (du,u,p,t) -&gt; du .= t .* u
jac = (J,u,p,t) -&gt; (J[1,1] = t; J[2,2] = t; J)
jp = Diagonal(zeros(2))
fun = ODEFunction(f; jac=jac, jac_prototype=jp)</code></pre><p>Note that the integrators will always make a deep copy of <code>fun.jac_prototype</code>, so there&#39;s no worry of aliasing.</p><p>In general the jacobian prototype can be anything that has <code>mul!</code> defined, in particular sparse matrices or custom lazy types that support <code>mul!</code>. A special case is when the <code>jac_prototype</code> is a <code>AbstractDiffEqLinearOperator</code>, in which case you do not need to supply <code>jac</code> as it is automatically set to <code>update_coefficients!</code>. Refer to the <a href="fundamentals/@ref">DiffEqOperators</a> section for more information on setting up time/parameter dependent operators.</p><h2 id="Sparsity-Handling"><a class="docs-heading-anchor" href="#Sparsity-Handling">Sparsity Handling</a><a id="Sparsity-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#Sparsity-Handling" title="Permalink"></a></h2><p>The solver libraries internally use packages such as <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a> and <a href="https://github.com/JuliaDiff/SparseDiffTools.jl">SparseDiffTools.jl</a> for high performance calculation of sparse Jacobians and Hessians, along with matrix-free calculations of Jacobian-Vector products (J<em>v), vector-Jacobian products (v&#39;</em>J), and Hessian-vector products (H*v). The SciML interface gives users the ability to control these connections in order to allow for top notch performance.</p><p>The key arguments in the SciMLFunction is the <code>prototype</code>, which is an object that will be used as the underlying Jacobian/Hessian. Thus if one wants to use a sparse Jacobian, one should specify <code>jac_prototype</code> to be a sparse matrix. The sparsity pattern used in the differentiation scheme is defined by <code>sparsity</code>. By default, <code>sparsity=jac_prototype</code>, meaning that the sparse automatic differentiation scheme should specialize on the sparsity pattern given by the actual sparsity pattern. This can be overridden to say perform partial matrix coloring approximations. Additionally, the color vector for the sparse differentiation directions can be specified directly via <code>colorvec</code>. For more information on how these arguments control the differentiation process, see the aforementioned differentiation library documentations.</p><h2 id="SciMLFunctions-API"><a class="docs-heading-anchor" href="#SciMLFunctions-API">SciMLFunctions API</a><a id="SciMLFunctions-API-1"></a><a class="docs-heading-anchor-permalink" href="#SciMLFunctions-API" title="Permalink"></a></h2><p>Should be generated from docstrings!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../PDE/">« The PDE Definition Interface</a><a class="docs-footer-nextpage" href="../Differentiation/">Controls for Automatic Differentiation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.7 on <span class="colophon-date" title="Thursday 30 September 2021 14:19">Thursday 30 September 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
